---
title: "Limpieza IDs Contratistas"
subtitle: "SIGMAP: Semillero de Investigación en Gestión, Mejora y Análisis de Procesos"
author: "Nicolas Arrieta y Lizeth Jerez"
date: "11/11/2020"
output:
  html_document: 
    code_folding: hide
    theme: flatly
    toc: yes
    toc_depth: 2
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

# Descripción

Debido a que la entrada del nombre de contratistas e identificación se digita de forma manual en el portal de SECOP, se generan algunos problemas de digitación que afectan la calidad de datos. Por ejemplo, en la columna de identificación del contratista se encuentran caracteres no numéricos, como puntos y alfabeticos, por otro lado, existen diferentes nombres para un único contratista. Por consiguiente, este documento describe una forma de abordar el problema y mejorar la calidad de los datos y obtener una mejor fuente para los procesos de analisis consecuentes.

El paquete [fuzzyjoin](https://cran.r-project.org/web/packages/fuzzyjoin/fuzzyjoin.pdf) permite diferentes métodos que realizan uniones de dos tablas donde su atributo llave no está estandarizado o tiene otra conotación similar. Por ejemplo, si existen dos tablas el cual su atributo llave es el departamento, es posible encontrarse con que en una tabla exista un 'Bogotá', mientras que la otra lo tome como 'Bogotá D.C.', en este caso ambas cadenas hacen referencia al mismo valor, sin embargo, la segunda tabla al poseer caracteres adicionales, durante el procesamiento se interpretan como una categoria diferente.

En esta estrategia metodologica se emplea las funciones de fuuzyjoin que se basan en algoritmos de [stringdist](https://www.joyofdata.de/blog/comparison-of-string-distance-algorithms/), las cuales permiten calcular qué tan diferentes son dos cadenas de carateres. En este caso existen métodos sencillos, pero otros más complejos que pueden determinar mayor precisión en la limpieza.

En nuestro caso se plantea el uso de una tabla con los contratistas que presentan problemas de coherencia, es decir, cuando tienen más de un ID con el mismo nombre, o viceversa, cuando tienen más de un nombre con el mismo ID. A partir de esto, se pretende emparejarla con la tabla completa con la finalidad de asignar un valor estándar para las variaciones vistas anteriormente.

# Librerias

La libreria principal es fuzzyjoin, la cual se encarga de comparar cada uno de los registros y determinar la similitud entre estos. Esta libreria emplea algoritmos de comparación difuza (fuzzyjoin) de la libreria stringdist, por lo tanto, esta también debe ser anexada. por último, la libreria tidyverse nos permite la manipulación de las tablas bajo en entorno tidy.

```{r librerias, message = F, warning = F}
library(tidyverse)
library(stringdist)
library(fuzzyjoin)
library(knitr)

knitr::opts_chunk$set(message = F, 
                      warning = F, 
                      fig.align = "center")
```

# Conjunto de datos

## Carga de datos

A la fecha en que se escribe este documento, se ha probado este método en los contratos del SECOP I durante el periodo de emergencia sanitaria por el COVID 19, especifícamente, el periodo data de mediados de marzo del 2020 hasta mediados de noviembre del 2020. A continuación, se carga el archivo con la columna de la identificación de contratistas y nombre del contratista.

```{r carga de datos}
# Dirección del archivo
direccion_comp <- paste0('C:/Users/nico2/Proyectos/contratacion_publica',
                         '/dashCCo/Datasets_complementos/')
# Lectura
contratos_SI <- read_csv(file = paste0(direccion_comp, 
                                       "contratos_covid19_SI.csv"),
                      locale = locale(encoding = "UTF-8"))

# Cambio de nombre de columnas
contratos_SI <- contratos_SI %>% 
  select(identificacion_del_contratista, nom_raz_social_contratista) %>% 
  rename(id_contratista = identificacion_del_contratista,
         nom_contratista = nom_raz_social_contratista)

head(contratos_SI, 10)
```

## Indicadores de efectividad

Es importante resaltar la efectividad del método, por lo tanto, es necesario registrar la situación incial del conjunto de datos. Por lo tanto, se identifico que existen `r nrow(unique(contratos_SI))` número de contratistas únicos con identificación y nombre en conjunto. Sin embargo, existen  `r length(unique(contratos_SI$id_contratista))` contratistas con un única identificación y `r length(unique(contratos_SI$nom_contratista))` para un único nombre.

Como se puede observar existe una gran diferencia entre cada uno de los datos. Por lo tanto, se busca la necesidad de solucionar este problema. Si tomamos el valor más bajo, correspondiente a los contratistas por identificación, encontramos que existe una diferencia de `r nrow(unique(contratos_SI))- length(unique(contratos_SI$id_contratista))` frente a la combinación y `r length(unique(contratos_SI$nom_contratista)) - length(unique(contratos_SI$id_contratista))` frente al nombre de contratistas.

# Limpieza de indentificación de Contratistas

## Ajustes previos

Es necesario limpiar los nombres que poseen caracteres erroneos durante el proceso de obtención, en el siguiente código se presenta la extracción. Por ejemplo, observe los siguientes casos

```{r ajustes previos 1}
car_limpieza <- c("\\¿", "<U+0096>", "<u+0096>","\\(",": ", "<u+0093>", 
                  "<U+0093>", "<u+0094>","<U+0094>", "/\\)\\(", "\\(")

head(contratos_SI[str_detect(contratos_SI$nom_contratista, 
                        pattern = car_limpieza[5]),])
```

En el siguiente código se presenta la forma de remover los caracteres

```{r ajustes previos 1.2}
# Limpieza de caracteres en el atributo
contratos_SI <- contratos_SI %>% 
  mutate(nom_contratista = str_remove_all(string = nom_contratista,
                                     pattern = car_limpieza),
    nom_contratista = str_to_upper(nom_contratista),
    nom_contratista = iconv(nom_contratista, 
                            from = "UTF-8",  
                            to = 'ASCII//TRANSLIT'))
```

Adicionalmente, se realizan algunos ajustes muy sencillo se presentan en los acronimos de las razones sociales.

```{r ajustes previos 2}
# Reemplazo de caracteres
contratos_SI <- contratos_SI %>% 
  mutate(nom_contratista = str_replace_all(nom_contratista, 
                                      pattern = "S.A.S.", replacement = "SAS"))
contratos_SI <- contratos_SI %>% 
  mutate(nom_contratista = str_replace_all(nom_contratista, 
                                      pattern = "S.A.S", replacement = "SAS"))

contratos_SI <- contratos_SI %>% 
  mutate(nom_contratista = str_replace_all(nom_contratista, 
                                      pattern = "S.A.", replacement = "SA"))
contratos_SI <- contratos_SI %>% 
  mutate(nom_contratista = str_replace_all(nom_contratista, 
                                      pattern = "S.A", replacement = "SA"))
```

Finalmente, se obtiene el conjunto de datos inicial

```{r extraccion datos de interes}
# Extraccion del atributo
contratos_SI <- contratos_SI %>% unique()
```

De igual manera obtenemos las estadísticas principales:

 - *Número de registros únicos:* `r nrow(unique(contratos_SI))`
 - *Número de IDs únicos:* `r length(unique(contratos_SI$id_contratista))`
 - *Número de nombres únicos:* `r length(unique(contratos_SI$nom_contratista))`

## Método Fuzzyjoin

En el primer caso, se extraen los contratistas que presentan más de un nombre para un único id.

```{r contratistas con el error en nombre}
# Extracción de los que presentan anomalias
# A. Varios nombres en el id
dif_nom <- contratos_SI %>% group_by(id_contratista) %>%
  summarize(n_dif = n_distinct(nom_contratista)) %>% filter(n_dif > 1)
```

En el segundo caso, se extraen los contratistas que presentan más de un id para un único nombre.

```{r contratistas con el error en ID}
# B. Varios ID con un solo nombre
dif_nit <- contratos_SI %>% group_by(nom_contratista) %>%
  summarize(n_dif = n_distinct(id_contratista)) %>% filter(n_dif > 1)
```

Se unen ambos conjunto de datos para tener los contratistas que presentan problema.

```{r extraccion de contratistas}
# Busqueda y selección de los que presentan anomalias
# Nota: Se tuvo que seleccionar solamente una representaciónd e cada nombre
#       (más frecuente), porque al hacer el reemplazo en la parte final se
#       repetia el problema.
contratistas_dif <- contratos_SI[
  contratos_SI$id_contratista %in% dif_nom$id_contratista |
  contratos_SI$nom_contratista %in% dif_nit$nom_contratista,] %>% 
  group_by(id_contratista) %>% slice_max(nom_contratista) %>% ungroup() %>% 
  group_by(nom_contratista) %>% slice_max(id_contratista) %>% ungroup()
```

Por lo tanto, se obtiene que existen `r nrow(contratistas_dif)` contratista con esta anomalia.

A continuación, se presenta la ejecución del algoritmo fuzzyjoin mediante el uso de la libreria stringdist. Como se puede observar se determinó que se emparejan contratistas que presenten por máximo 4 diferencias (para cada uno del los atributos).

```{r ejecucion del algoritmo}
# Ejecución del alg. Fuzzy join para emparejar los nombres y nits
resultado_match_cont <- contratos_SI %>% 
  stringdist_inner_join(contratistas_dif %>% 
                         rename(id_contratista_2 = id_contratista,
                                nom_contratista_2 = nom_contratista), 
                       by = c(id_contratista = "id_contratista_2",
                              nom_contratista = "nom_contratista_2"),
                       max_dist = 4, distance_col = "resl")
```

Debido a que algunas uniones son muy dificiles de determinar como validas, se retiran estas asignaciones.

```{r eliminacion casos poco efectivos}
# Eliminación de los cruces monos efectivos y redundantes
resultado_match_cont <- resultado_match_cont %>% 
  filter(!(id_contratista.resl == 0 & nom_contratista.resl == 0), # redundancia
         !(id_contratista.resl == 4 & nom_contratista.resl == 4), # no aciertos
         !(id_contratista.resl == 4 & nom_contratista.resl >= 2),
         !(id_contratista.resl == 3 & nom_contratista.resl >= 3),
         !(id_contratista.resl == 2 & nom_contratista.resl >= 4))
```

Antes de la unión definitiva se ajustan algunos valores manuales encontrados por busqueda detallada.

```{r ajustes manuales}
# Ajuste manual
# Cruz roja
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
                          "LA CRUZ ROJA COLOMBIANA"), "nom_contratista_2"] <- 
  "CRUZ ROJA COLOMBIANA SECCIONAL CUNDINAMARCA Y BOGOTA"
# Espacio en WILLIAM  OSWALDO  DIAZ JOJOA
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
                      "WILLIAM  OSADO  DIAZ JOJOA"), "nom_contratista_2"] <- 
  "WILLIAM OSADO DIAZ JOJOA"
# Espacio en TALENTO COMERCIALIZADORA SAS
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
                 "TALENTO COMERCIALIZADORA SA"), "nom_contratista_2"] <- 
  "TALENTO COMERCIALIZADORA SAS"
# Espacio en SUMINISTROS Y NEGOCIOS DE LA SABANA SAS
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
          "SUMINISTROS Y NEGOCIOS DE LA SABANAS SAS"), "nom_contratista_2"] <- 
  "SUMINISTROS Y NEGOCIOS DE LA SABANA SAS"

# Espacio en R.R. EDITORES RAMIREZ Y RAMIREZ LIMITADA
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
          "R.R. EDITORES RAMIREZ Y RAMIREZ LIMITADA"), "nom_contratista_2"] <- 
  "R.R EDITORES RAMIREZ Y RAMIREZ LTDA"

# Espacio en PRODUCLINICOS DEL SURR LTDA
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
            "PRODUCLINICOS DEL SURR LTDA"), "nom_contratista_2"] <- 
  "PRODUCLINICOS DEL SUR LTDA"

# Espacio en LM INSTRUMENTS SA
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
                        "LM INSTRUMENTS SA"), "nom_contratista_2"] <- 
  "LM INSTRUMENTS SAS"

# Espacio en DATOS Y GESTIONES E.A.T.
resultado_match_cont[str_detect(resultado_match_cont$nom_contratista_2,
                        "DATOS Y GESTIONES E.A.T."), "nom_contratista_2"] <- 
  "DATOS Y GESTION E.A.T."
```

Por último se une la tabla de los contratistas resueltos en el emparejamiento en la tabla completa.

```{r actualizacion del dataset}
contratos_SI_res <- contratos_SI %>% merge(x = ., y = resultado_match_cont %>% 
                  select(nom_contratista, nom_contratista_2, id_contratista_2),
                  by = "nom_contratista", all.x = T) %>% 
  mutate(id_contratista = case_when(
    !is.na(id_contratista_2) ~ id_contratista_2,
    TRUE ~ id_contratista),
    nom_contratista = case_when(
      !is.na(nom_contratista_2) ~ nom_contratista_2,
      TRUE ~ nom_contratista)) %>% 
  select(-c("nom_contratista_2", "id_contratista_2"))
```

## Resultados

En resumen, se presentan los siguientes resultados obtenidos por medio del método propuesto. Cabe resaltar que aún existe capacidad de mejorar los resultados y mantener una brecha más corta de las diferencias entre los contratistas por ID y nombre.

```{r resultados}
rest <- tibble(Campo = c("Número de registros únicos", 
                        "Número de IDs únicos",
                        "Número de nombres únicos"),
              Inicial = c(nrow(unique(contratos_SI)),
                        length(unique(contratos_SI$id_contratista)),
                        length(unique(contratos_SI$nom_contratista))),
              Final = c(nrow(unique(contratos_SI_res)),
                        length(unique(contratos_SI_res$id_contratista)),
                        length(unique(contratos_SI_res$nom_contratista))))

rest <- rest %>% mutate(Diferencia = Inicial - Final)

kable(rest, caption = "Resultado del método Fuzzyjoin") 
```

